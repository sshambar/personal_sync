#!/bin/bash
# -*- mode:sh; sh-indentation:2 -*- vim:set ft=sh et sw=2 ts=2:
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2025 Scott Shambarger
#
# trashit v1.2.0 - Index and search messages in Maildirs to trash/delete
# Author: Scott Shambarger <devel@shambarger.net>
#

BATCH_SIZE=10
# only used for if doveadm not available
DBFILE="/tmp/db-<user>"

warn() { local IFS; printf >&2 '%s\n' "$*"; }
die() { local IFS; warn "$*"; exit 1; }
msg() { local IFS; [[ $QUIET ]] || printf "%s\n" "$*"; }

USEDB=''
command >/dev/null -v doveadm || USEDB=1

usage() { # [ <err> ]
  warn "$* (use -h for help)"
  exit 1
}

help() {
  warn "Trash messages matching patterns"
  warn "trashit ${USEDB:+[ rebuild ] }<option>"
  warn "<options> are:"
  [[ $UID == 0 ]] && warn "  -u <name> - for user <name>"
  warn "  -t <addr> - match Delivered-To (<addr>@...)"
  warn "  -f <from> - match part of From"
  warn "  -c - display From line on matches (no action)"
  warn "  -C - display file, To and From line on matches (no action)"
  [[ $USEDB ]] || warn "  -l - force use of flatfile database"
  warn "  -n - dry-run (no action)"
  warn "  -o <days> - only files older than <days> ago"
  warn "  -a <days> - only files after <days> ago (> 0)"
  warn "  -r <days> - remove if older than <days> ago"
  warn "  -q - quiet"
  warn "  -v - show more details"
  warn "Requires ${USEDB:+rebuild or }-f and/or -t"
  exit 0
}

REBUILD='' TO='' FROM='' CHECK='' DRYRUN='' OLDER='' AFTER='' REMOVE=''
QUIET='' VERBOSE='' DBUSER='' DOVEARGS=()
NOW=$(date +%s)

while [[ $1 ]]; do
  case $1 in
    rebuild) REBUILD=1 ;;
    -a) shift; [[ $1 ]] || usage "Option -a requires <days>"
        (( $1 > 0 )) || usage "Option -a must be > 0"
        AFTER=$(( NOW - ( $1 * 86400 ) ))
        ;;
    -c) CHECK=1 ;;
    -C) CHECK=2 ;;
    -f) shift; [[ $1 ]] || usage "Option -f requires <from>"
        FROM=${1#-}
        ;;
    -h) help ;;
    -l) USEDB=1 ;;
    -n) DRYRUN=1 ;;
    -o) shift; [[ $1 ]] || usage "Option -o requires <days>"
        (( $1 > 0 )) && {
          OLDER=$(( NOW - ( $1 * 86400 ) ))
        }
        ;;
    -q) QUIET=1 ;;
    -r) shift; [[ $1 ]] || usage "Option -r requires <days>"
        (( $1 > 0 )) && {
          REMOVE=$(( NOW - ( $1 * 86400 ) ))
        }
        ;;
    -t) shift; [[ $1 ]] || usage "Option -t requires <addr>"
        TO=${1#-}
        [[ $TO =~ @ ]] && TO=${TO%@*}
        ;;
    -u) [[ $UID == 0 ]] || usage "Option -u only usable as root user"
        shift
        DBUSER=$1
        [[ $DBUSER ]] || usage "Option -u requires <user>"
        ;;
    -v) VERBOSE=1 ;;
    *) usage "Unknown arg: $1"
       ;;
  esac
  shift
done

[[ $REBUILD || $TO || $FROM ]] ||
  usage "Requires ${USEDB:+rebuild or }-f and/or -t"

# sanity check args
[[ $REMOVE && $OLDER ]] && { (( REMOVE < OLDER )) || REMOVE=$OLDER; }
[[ $OLDER && $AFTER ]] && {
  (( AFTER < OLDER )) || die "-a <days> must be greater than -o <days>"; }

if [[ $DBUSER ]]; then
  if [[ $USEDB ]]; then
    # ensure local user exists
    id &>/dev/null "$DBUSER" || die "No such user $DBUSER"
    eval HOME=~"$DBUSER"
  else
    DOVEARGS+=("-u" "$DBUSER")
  fi
else
  DBUSER=$USER
fi

# only used for if doveadm not available
DBFILE=${DBFILE/<user>/$DBUSER}

rebuild_db() {
  warn "Generating database.  This may take a few mins..."
  # TODO main weakness here is multi-line From: are incomplete...
  grep -RiZ -m 2 -E '^(delivered-to|from):' > "$DBFILE.tmp"

  # now process file
  local line file nfile pfile header pheader
  local from to
  if read -rd '' line; then
    nfile=${line}
    while read -rd '' line || [[ $line ]]; do
      pfile=$file
      file=$nfile
      nfile=${line#*$'\n'}
      pheader=$header
      header=${line%$'\n'"$nfile"}

      if [[ $pfile == "$file" ]]; then
        if [[ ${header:4:1} != : ]]; then
          to=$header
          from=$pheader
        else
          from=$header
          to=$pheader
        fi
      elif [[ $file != "$nfile" ]]; then
        # lone header
        [[ ${header:4:1} != : ]] && { to=$header; from=''; }
      fi
      # to required, from optional
      [[ $to ]] && {
        to=${to:14}
        echo "$file|${to%@*}|${from:6}"
        to='' from=''
      }
    done
    : # ignore read rc
  fi < "$DBFILE.tmp" > "$DBFILE.new" || exit
  rm "$DBFILE.tmp"
  mv "$DBFILE.new" "$DBFILE"
  chown "$DBUSER:$DBUSER" "$DBFILE"
}

[[ $USEDB ]] && {
  # setup DB environment
  umask 0077

  cd ~/Maildir/cur || exit
  shopt -s nullglob || exit

  [[ -r $DBFILE || $REBUILD ]] || {
    read >&2 -rp "Database missing, generate it now? (Y/n): " || exit
    [[ $REPLY =~ ^(y|Y|)$ ]] || exit 0
    REBUILD=1
  }

  [[ $REBUILD ]] && rebuild_db
  [[ $TO || $FROM ]] || exit 0
}

search_db() {
  local line age

  while read -r line; do
    age=${line%%.*}
    [[ $AFTER ]] && {
      (( age >= AFTER )) || continue
    }
    [[ $OLDER ]] && {
      (( age >= OLDER )) && continue
    }
    if [[ $CHECK ]]; then
      [[ $VERBOSE ]] && echo "$(date -d @"${line%%.*}")"
      if [[ $CHECK == 2 ]]; then
        echo "${line//|/ | }"
      else
        line=${line#*|}
        echo "${line#*|}"
      fi
    else
      echo "${line%%|*}"
    fi
    (( count++ )) || :
  done < <(grep -Ei "[^|]+\|${TO:-[^|]+}\|.*$FROM.*" "$DBFILE")
}

search_doveadm() {
  local search line file from to extra fields="guid uid"

  search=(mailbox inbox)
  [[ $TO ]] && search+=(header delivered-to "$TO")
  [[ $FROM ]] && search+=(from "$FROM")
  [[ $OLDER ]] && search+=(before "$OLDER")
  [[ $AFTER ]] && search+=(since "$AFTER")

  [[ $CHECK ]] && fields="hdr.from hdr.delivered-to $fields"

  while read -r line; do
    case $line in
      hdr.from:*) from=${line:10}; extra=1 ;;
      hdr.delivered-to:*) [[ $TO ]] && to=${line:18} ;;
      guid:*) file=${line:6} ;;
      uid:*) # last field, trigger output
        if [[ $CHECK ]]; then
          [[ $VERBOSE ]] && echo "$(date -d @"${file%%.*}") | ${line:5}"
          if [[ $CHECK == 2 ]]; then
            echo "$file | ${to%@*} | $from"
          else
            echo "$from"
          fi
        else
          echo "$file|${line:5}"
        fi
        extra=''
        (( count++ )) || :
        ;;
      *)
        [[ $extra ]] && {
          extra=''
          from+=${line:1}
        }
        ;;
    esac
  done < <(doveadm fetch "${DOVEARGS[@]}" "$fields" "${search[@]}")
}

do_query() {
  local count=0 rc=0
  if [[ $USEDB ]]; then
    search_db || rc=$?
  else
    search_doveadm || rc=$?
  fi
  [[ $CHECK ]] && {
    if (( count > 0 )); then
      msg "Found $count matches"
    else
      msg "No matches"
    fi
  }
  return $rc
}

[[ $CHECK ]] && {
  do_query
  exit
}

action() {
  local IFS
  [[ $VERBOSE ]] && warn "$*"
  [[ $DRYRUN ]] && return
  "$@"
}

delete_mail() { # <uid>...
  [[ $1 ]] || return 0
  if [[ $USEDB ]]; then
    action rm -f "$@"
  else
    local IFS=,
    action doveadm flags add "${DOVEARGS[@]}" '\Deleted' \
           mailbox inbox uid "$*" || return
    action doveadm expunge "${DOVEARGS[@]}" mailbox inbox uid "$*" || return
  fi
  (( deleted += ${#@} )) || :
}

trash_mail() { # <uid>...
  [[ $1 ]] || return 0
  if [[ $USEDB ]]; then
    local file
    for file in "$@"; do
      [[ -f $file ]] && {
        # fail on permissions error
        action mv "$file" ~/Maildir/.Trash/cur || return
        (( trashed++ )) || :
      }
    done
  else
    local IFS=,
    action doveadm move "${DOVEARGS[@]}" Trash mailbox inbox uid "$*" || return
    (( trashed += ${#@} )) || :
  fi
}

# updates rem_set() and trash_set()
check_sets() { # <batch-size>
  local rc=0
  (( ${#rem_set[@]} >= $1 )) && {
    delete_mail "${rem_set[@]}" || rc=$?
    rem_set=()
  }
  (( ${#trash_set[@]} >= $1 )) && {
    trash_mail "${trash_set[@]}" || rc=$?
    trash_set=()
  }
  return $rc
}

do_trashit() {
  local trashed=0 wild=0 deleted=0
  local line file remove
  local rem_set=() trash_set=()

  while read -r line; do
    file=${line%%|*}
    if [[ $USEDB ]]; then
      [[ -f $file ]] || {
        for item in "${file%:*}"*; do break; done
        [[ $item ]] || continue
        file=${item##*/}
        (( wild++ ))
      }
    fi
    [[ $REMOVE ]] && {
      age=${file%%.*}
      (( age < REMOVE )) && remove=1 || remove=''
    }
    # show uid if verbose
    [[ $VERBOSE ]] && file=$line
    if [[ $remove ]]; then
      msg "removing $file"
      rem_set+=("${line#*|}")
    else
      msg "trashing $file"
      trash_set+=("${line#*|}")
    fi

    check_sets "$BATCH_SIZE" || break

  done < <(do_query)

  check_sets 0

  (( trashed > 0 )) && msg "Trashed $trashed"
  (( deleted > 0 )) && msg "Deleted $deleted"
  (( wild > 0 )) && msg "  ($wild needed wildcards)"
  [[ $DRYRUN ]] && echo "DRY-RUN - NO ACTION TAKEN"
}

cnt=$(do_query | wc -l)
[[ $cnt == 0 ]] && die "No matches"
read >&2 -rp "Found $cnt, move to trash? (y/N): " || exit
[[ $REPLY =~ ^(y|Y)$ ]] || exit

do_trashit
