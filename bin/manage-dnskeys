#!/bin/bash
# -*- mode: shell-script; fill-column: 78 -*-
# ex: filetype=sh
#
# manage-dnskeys v0.9 Manage bind DNSKEYs via cron
# Author: Scott Shambarger <devel@shambarger.net>
#
# Run with '-h' to get a quick summary of what this script does
#
# Copyright 2019 Scott Shambarger.  All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

BIND_USER=${BIND_USER:-named}
# for sync, this should be in ~named/.ssh/config
SSH_REMOTE=${SSH_REMOTE:-sync:}
VERBOSE=${VERBOSE:-}

usage () {
  echo "Usage: ${0##*/} [ <options> ]"
  echo "Manage DNSSEC keys under /var/named/dyndb-ldap"
  echo "If run without args, runs dnssec-keymgr and dnssec-coverage"
  echo "  in each keys directory"
  echo "<options> can be any of:"
  echo "  help (or -h) - shows this help"
  echo "  verbose - show what's being done"
  echo "  sync - runs rsync over ssh to retrieve keys from the sync server"
  echo "         (rsync-source '$SSH_REMOTE') and then runs dnssec-coverage"
  echo "  test - performs a dry-run (but still run coverage)"
}

test=
sync=
rsync_args=

for f in "$@"; do
  case $f in
    sync)
      sync=1
      ;;
    test)
      test=1
      rsync_args="-n $rsync_args"
      ;;
    verbose)
      VERBOSE=1
      rsync_args="--progress $rsync_args"
      ;;
    help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $f"
      usage
      exit 1
      ;;
  esac
done

# create keys with correct uid (private keys are chmod 600!)
if [ $EUID -eq 0 ]; then
  rpath=`realpath $0`
  exec su -s /bin/bash -c "$(printf "%q " "$rpath" "$@")" $BIND_USER
fi

[ "$USER" != "$BIND_USER" ] && echo "Run as user $BIND_USER or root" && exit 1

verbose() {
  [ -n "$VERBOSE" ] && echo "$*"
}

#
# Run dnssec-keymgr for each of the dnsdb-ldap key directories...
#
shopt -s nullglob
for keydir in /var/named/dyndb-ldap/*/master/*/keys; do
  verbose "Processing keydir '$keydir'"
  # update keys if necessary...
  if [ -n "$sync" ]; then
    prefix=${keydir#/var/named/}
    target=${keydir%/keys}
    verbose "Running rsync -aO $rsync_args --safe-links --timeout=300 '${SSH_REMOTE}$prefix' '$target'"
    rsync -aO $rsync_args --safe-links --timeout=300 "${SSH_REMOTE}$prefix" "$target"
    [ $? -ne 0 ] && echo "rsync failed for $keydir" && continue
  else
    verbose "Running dnssec-keymgr -K <keydir>"
    [ -n "$test" ] || dnssec-keymgr -K "$keydir"
    [ $? -ne 0 ] && echo "dnssec-keymgr failed for $keydir" && continue
  fi

  # now verify everything is ok
  verbose "Running dnssec-coverage -m 604800 -K <keydir>"
  dnssec-coverage -m 604800 -K "$keydir" > /dev/null
  if [ $? -ne 0 ]; then
    echo "dnssec-coverage indicates errors in $keydir"
    dnssec-coverage -m 604800 -K "$keydir"
  fi
done

# Local Variables:
# mode: sh
# sh-basic-offset: 2
# sh-indentation: 2
# indent-tabs-mode: nil
# End:
